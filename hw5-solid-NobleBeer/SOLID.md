#### Какие принципы SOLID **учтены** при реализации _связного списка_? Проиллюстрируйте примером каждый из названых принципов. 

При реализации связного списка были учтены следующие принципы:
- Single Responsibility Principle. Методы выполняют ровно то единственное,
что должны. Например метод toArray просто возвращает массив, но 
не распечатывает его.
- Open closed Principle - вложенный класс Node недоступен извне
и используется только внутри классов StrangeMyList и LinkedMyList.
- Liskov substitution Principle. Для того чтобы следовать принципу 
подстановки Барбары Лисков необходимо в базовый (родительский) 
класс выносить только общую логику, характерную для классов
наследников, которые будут ее реализовывать и, соответственно, 
можно будет базовый класс без проблем заменить на его класс-наследник.
В данной работе ВСЕ методы класса-родителя реализованы в классах-наследниках.

#### Какие принципы SOLID **не были** учтены при реализации _связного списка_? Проиллюстрируйте примером каждый из названых принципов. Объясните, почему

- Interface Segregation Principle - мы не применяли интерфейсы в данной работе.
- Dependency Inversion Principle. Если я еще не забыла совсем все, то этот пункт
подразумевает в общих чернах ослабление связи между классами, т.е.
переход от композиции (в классе экземпляр класса) к агрегации (без лишних new).
Я, как маленький и не очень умный студент, создаю экземпляры класса Node направо и налево
в LinkedMyList, только посмотрите на обилие переменных Node current. Именно из-за этого мы 
не соблюдаем этот принцип. А могла бы создать контейнер с ссылкой, наверно.

#### Какие принципы SOLID **учтены** при реализации _странного связного списка_? Проиллюстрируйте примером каждый из названых принципов.

- Single Responsibility Principle. Методы выполняют ровно то единственное,
что должны. Например метод toArray просто возвращает массив, но
не распечатывает его.
- Open closed Principle - вложенный класс Node недоступен извне
и используется только внутри классов StrangeMyList и LinkedMyList.
- Liskov substitution Principle. Для того чтобы следовать принципу
  подстановки Барбары Лисков необходимо в базовый (родительский)
  класс выносить только общую логику, характерную для классов
  наследников, которые будут ее реализовывать и, соответственно,
  можно будет базовый класс без проблем заменить на его класс-наследник.
  В данной работе ВСЕ методы класса-родителя реализованы в классах-наследниках.

#### Какие принципы SOLID **не были** учтены при реализации _странного связного списка_? Проиллюстрируйте примером каждый из названых принципов.

- Interface Segregation Principle - мы не применяли интерфейсы в данной работе.
- Dependency Inversion Principle. По аналогии с LinkedList. Кстати, мы будем проходить
ассоциации и раннее/позднее связывание? 
